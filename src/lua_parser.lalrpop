use std::str::FromStr;
use crate::ast::{Program, Function, Statement, Expression, Term, Operation, TableConstructionIndex};

grammar;

pub Program: Program = {
    <body: (<Statement>)*> => body,
}

Statement: Statement = {
    "return" <e:Expression> => Statement::Return(e),
    "local" <Identifier> "=" <Expression> => Statement::Local(<>),

    "if" <Expression> "then" <(<Statement>)*> <("elseif" <Expression> "then" <(<Statement>)*>)*> <("else" <(<Statement>)*>)?> "end" =>
        Statement::If(<>),

    "for" <Identifier> "=" <Expression> "," <Expression> <("," <Expression>)?> "do" <(<Statement>)*> "end" =>
        Statement::NumericFor(<>),

    "function" <name:Identifier> "(" <parameters:ParameterList> ")" <body: (<Statement>)*> "end" =>
        Statement::Function(Function { name, parameters, body }),

    <Expression> "=" <Expression> => Statement::Assignment(<>),
    <e:Expression> => Statement::Expression(e),
}

Expression: Box<Expression> = {
    "function" "(" <parameters:ParameterList> ")" <body: (<Statement>)*> "end" =>
        Box::new(Expression::Function(parameters, body)),

    <a:LogicExpression> => a,
}

ParameterList: Vec<String> = {
    <parameters: (<Identifier> ",")*> <last:Identifier?> => {
        let mut parameters = parameters;
        parameters.extend(last);
        parameters
    },
}

LogicExpression = Tier<LogicOperation, ArithmaticExpression>;
LogicOperation: Operation = {
    "==" => Operation::Equals,
    ">" => Operation::GraterThan,
    "<" => Operation::LessThan,
    ">=" => Operation::GraterThanEquals,
    "<=" => Operation::LessThanEquals,
}

ArithmaticExpression = Tier<ExpressionOperation, Factor>;
ExpressionOperation: Operation = {
    "+" => Operation::Add,
    "-" => Operation::Subtract,
}

Factor = Tier<FactorOperation, Access>;
FactorOperation: Operation = {
    "*" => Operation::Multiply,
    "/" => Operation::Divide,
}

Access: Box<Expression> = {
    <Access> "." <Identifier> => Box::new(Expression::Dot(<>)),
    <Access> "[" <Expression> "]" => Box::new(Expression::Index(<>)),
    <Access> "(" <ArgumentList> ")" => Box::new(Expression::Call(<>)),
    Term
}

ArgumentList: Vec<Box<Expression>> = {
    <arguments: (<Expression> ",")*> <last: Expression?> => {
        let mut arguments = arguments;
        arguments.extend(last);
        arguments
    }
}

Tier<Op, NextTier>: Box<Expression> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expression::Binary(<>)),
    NextTier
}

Term: Box<Expression> = {
    <n:Number> => Box::new(Expression::Term(Term::Number(n))),
    <s:String> => Box::new(Expression::Term(Term::String(s))),
    <b:Boolean> => Box::new(Expression::Term(Term::Boolean(b))),
    <v:Identifier> => Box::new(Expression::Term(Term::Variable(v))),
    <TableLiteral>
}

TableIndex: TableConstructionIndex = {
    "[" <Expression> "]" => TableConstructionIndex::Value(<>),
    <Identifier> => TableConstructionIndex::Name(<>),
}

TableItem = <(<TableIndex> "=")?> <Expression>;
TableLiteral: Box<Expression> = {
    "{" <items: (<TableItem> ",")*> <last: (<TableItem>)?> "}" => {
        let mut items = items;
        items.extend(last);
        Box::new(Expression::Term(Term::Table(items)))
    },
}

Boolean: bool = {
    "true" => true,
    "false" => false,
}

Number: f64 = <s:r"(\d+\.\d*)|(\d*\.\d+)|(\d+)"> => f64::from_str(s).unwrap();
String: String = <s:r#""[^"]*""#> => s[1..s.len()-1].to_owned();
Identifier: String = <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_owned();

match {
    r"\s*" => {},
    r"--.*\n" => {},
} else {
    _
}
